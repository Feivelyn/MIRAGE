
class CSecondaryInputController inherit CInputController

	var string m_sTaskByMouseCursor;

	var ^CObjMgr m_pxObjMgr;
	var bool m_bLMB, m_bRMB;
	var point m_xDragBoxBegin;
	var point m_xMousePos;

	var int m_iState;
	var string m_sCommand;
	var string m_sTTPath;
	var string m_sTTOriginal;
	var string m_sCursor;

	var ^CObj m_pxItem;

	var ^CObjSelection m_pxSelection;

	var array string m_asTargetTypes;
	var array string m_asTargetClasses;
	var array string m_asTargetExcludes;
	var array string m_asTargetOwner;
	var int m_iPreviousCursor;

	var int m_iMT_Invalid;
	var int m_iMT_MouseMove;
	var int m_iMT_MouseLBtnDown;
	var int m_iMT_MouseRBtnDown;
	var int m_iMT_MouseLBtnUp;
	var int m_iMT_MouseRBtnUp;
	var int m_iMT_MouseLBtnDoubleClick;
	var int m_iMT_MouseRBtnDoubleClick;
	var int m_iMT_KeyDown;
	var int m_iMT_KeyUp;
	var int m_iMT_MouseWheel;

	var int m_iNumKeyDown;

	var ^CObj m_pxMarkedObj;
	var ^CObjMgr.CRangeMarker m_pxRangeMarker;
	var CClntHndl m_xRangeMarkerObj;
	var bool m_bMouseMarker;

	var CClntHndl m_xRepairObj;

	export constructor()
		m_iMT_Invalid=-1;
		m_iMT_MouseMove=0;
		m_iMT_MouseLBtnDown=1;
		m_iMT_MouseRBtnDown=2;
		m_iMT_MouseLBtnUp=3;
		m_iMT_MouseRBtnUp=4;
		m_iMT_MouseLBtnDoubleClick=5;
		m_iMT_MouseRBtnDoubleClick=6;
		m_iMT_KeyDown=7;
		m_iMT_KeyUp=8;
		m_iMT_MouseWheel=9;
		m_bMouseMarker = false;
		m_iNumKeyDown = -1;
		m_pxObjMgr=^(CClientWrap.GetObjMgr());
		m_iState = 0;
		m_sCommand = "";
		m_pxSelection=^(CClientWrap.GetSelection());
	endconstructor;
	
	export destructor()
	enddestructor;
	
	export proc void Reset()
		m_bMouseMarker = false;
		m_iNumKeyDown = -1;
		m_pxObjMgr=^(CClientWrap.GetObjMgr());
		m_iState = 0;
		m_sCommand = "";
		m_sTTPath = "";
		m_sTTOriginal = "";
		m_pxSelection=^(CClientWrap.GetSelection());
		ResetController();
	endproc;
	
	export proc void SetCommand(string p_s)
		m_sCommand = p_s;
	endproc;
	
	export proc void SetItem(CGuid p_xGuid)
		m_pxItem = CGameWrap.GetObjMgr().GetObj(p_xGuid);
	endproc;
	
	export proc void SetRangeMarker(string p_s, ^CObj p_pxObj)
		if(m_pxSelection^.NumEntries()>0)then
			m_pxMarkedObj=m_pxSelection^[0].GetObj();
			if(m_pxMarkedObj!=null)then
				if(p_s.Find("jetpack")!=(-1)||p_s.Find("jetleap")!=(-1))then
					m_pxRangeMarker^.m_fRange=240.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
					m_pxRangeMarker^.m_xColor2={{255,150,150,0}};
				//Henry: for babbits exos jumpjet actionn
				elseif(p_s.Find("Babbage_ExoJumpjet_0")!=(-1))then
					m_pxRangeMarker^.m_fRange=300.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
					m_pxRangeMarker^.m_xColor2={{255,150,150,0}};
				elseif(p_s.Find("seas_jumpjet")!=-1)then
					m_pxRangeMarker^.m_fRange=300.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
					m_pxRangeMarker^.m_xColor2={{255,150,150,0}};
				elseif(p_s.Find("Jumpjet_0")!=(-1))then
					m_pxRangeMarker^.m_fRange=500.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
					m_pxRangeMarker^.m_xColor2={{255,150,150,0}};
				elseif(p_s.Find("Shotgunmove")!=(-1))then
					m_pxRangeMarker^.m_fRange=10.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,0,0,0}};
					m_pxRangeMarker^.m_xColor2={{255,200,0,0}};
				elseif(p_s.Find("Throwdownshot")!=(-1))then
					m_pxRangeMarker^.m_fRange=20.0f;
					m_pxRangeMarker^.m_xColor1={{255,0,0,0}};
					m_pxRangeMarker^.m_xColor2={{255,200,0,0}};
				elseif(p_s.Find("MickDundeeMove")!=(-1))then
					m_pxRangeMarker^.m_fRange=8.0f;
					m_pxRangeMarker^.m_xColor1={{0,0,255,0}};
					m_pxRangeMarker^.m_xColor2={{100,150,255,0}};
				elseif(p_s.Find("oracle")!=(-1))then
					m_pxRangeMarker^.m_fRange=20.0f;
					m_pxRangeMarker^.m_xColor1={{0,0,255,0}};
					m_pxRangeMarker^.m_xColor2={{100,150,255,0}};
				elseif(p_s.Find("Froze")>=0) then
					m_pxRangeMarker^.m_fRange=50.0f;
					m_pxRangeMarker^.m_xColor1={{0,0,255,0}};
					m_pxRangeMarker^.m_xColor2={{100,150,255,0}};
//				elseif(p_s.Find("Healing")!=(-1))then
//					m_pxRangeMarker^.m_fRange=50.0f;
//					m_pxRangeMarker^.m_xColor1={{0,255,255,0}};
//					m_pxRangeMarker^.m_xColor2={{100,255,100,0}};
				elseif(p_s.Find("pilot_fly")!=(-1))then
					m_pxRangeMarker^.m_fRange=120.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
					m_pxRangeMarker^.m_xColor2={{255,150,150,0}};
				else
					m_pxRangeMarker^.m_bVisible=false;
				endif;
				/*
				KLog.LogError("RangeMarker","m_bVisible: "+m_pxRangeMarker^.m_bVisible.ToString());
				KLog.LogError("RangeMarker","m_fRange: "+m_pxRangeMarker^.m_fRange.ToString());
				KLog.LogError("RangeMarker","m_fWidth1: "+m_pxRangeMarker^.m_fWidth1.ToString());
				KLog.LogError("RangeMarker","m_fWidth1: "+m_pxRangeMarker^.m_fWidth1.ToString());
				KLog.LogError("RangeMarker","m_vPos: "+m_pxRangeMarker^.m_vPos.ToString());
				*/
			endif;
		endif;
	endproc;
	
	proc void AddRangeMarker(real p_fRange, bool p_bCursor, CClntHndl p_xObj)
		if(m_pxRangeMarker==null)then
			m_pxRangeMarker=m_pxObjMgr^.CreateRangeMarker();
		endif;
		if(p_bCursor)then
			m_bMouseMarker = true;
		endif;
		m_pxRangeMarker^.SetObject(p_xObj.GetObj());
		m_xRangeMarkerObj=p_xObj;
		m_pxRangeMarker^.m_fRange=p_fRange;
		m_pxRangeMarker^.m_fWidth1=0.5f;
		m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
		m_pxRangeMarker^.m_xColor2={{255,150,150,100}};
		m_pxRangeMarker^.m_bVisible = true;
	endproc;

	export proc void SetNoneObjPath(string p_s)
		m_sTTPath = p_s;
		m_sTTOriginal = p_s;
		m_asTargetTypes = 0;
		m_asTargetOwner = 0;
		m_asTargetClasses = 0;
		m_asTargetExcludes = 0;
		if(m_sTTPath.Find("MapPing")!=-1) then
			m_asTargetTypes.AddEntry("ALL ");
		endif;
	endproc;
	
	export proc void SetTTPath(string p_s)
		m_sTTPath = p_s;
		m_sTTOriginal = p_s;
		m_asTargetTypes = 0;
		m_asTargetOwner = 0;
		m_asTargetClasses = 0;
		m_asTargetExcludes = 0;
		if(m_pxSelection^.NumEntries()<=0)then
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;
		var ^CObj pxObj = m_pxSelection^[0].GetObj();
		if(pxObj==null)then
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;
		var CTechTree xTechTree = pxObj^.GetTechTree();
		var bool bExceptions = m_sTTPath.Find("/DismountAll")>=0 || m_sTTPath.Find("/Repair")>=0;
		var bool bContinue = false;
		var ^CTechTree.CNode pxSecondary = xTechTree.FindNode(m_sTTPath+"/secondarycontroller");
		var ^CTechTree.CNode pxSecondaryClasses = xTechTree.FindNode(m_sTTPath+"/secondaryclasses");
		var ^CTechTree.CNode pxSecondaryExcludes = xTechTree.FindNode(m_sTTPath+"/secondaryexcludes");
		if(pxSecondary!=null || pxSecondaryClasses!=null || pxSecondaryExcludes!=null)then
			var int i, iC;
			var ^CTechTree.CNode pxSecondaryOwner = xTechTree.FindNode(m_sTTPath+"/secondarycontrollerowner");
			if(pxSecondaryOwner!=null)then
				iC = pxSecondaryOwner^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					m_asTargetOwner.AddEntry(pxSecondaryOwner^.GetSub(i)^.GetValue());
				endfor;
			endif;
			bContinue = true;
			if(pxSecondary!=null)then
				iC = pxSecondary^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					m_asTargetTypes.AddEntry(pxSecondary^.GetSub(i)^.GetValue());
				endfor;
			endif;
			if(pxSecondaryClasses!=null)then
				iC = pxSecondaryClasses^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					m_asTargetClasses.AddEntry(pxSecondaryClasses^.GetSub(i)^.GetValue());
				endfor;
			endif;
			if(pxSecondaryExcludes!=null)then
				iC = pxSecondaryExcludes^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					m_asTargetExcludes.AddEntry(pxSecondaryExcludes^.GetSub(i)^.GetValue());
				endfor;
			endif;
		endif;
		if(!bContinue && !bExceptions)then
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;
		if(m_sTTPath.Find("DismountAll")!=-1) then
			m_asTargetTypes.AddEntry("VEC3");
		elseif(m_sTTPath.Find("/Resurrect")!=-1)then
			m_asTargetTypes=0;
			m_asTargetTypes.AddEntry("SPRT");
			m_asTargetTypes.AddEntry("FOOD");
			m_asTargetTypes.AddEntry("NMST");
			m_asTargetTypes.AddEntry("VEC3");
			m_asTargetTypes.AddEntry("MGST");
			return;
		//Herny: added Tarnas action
		elseif(m_sTTPath.Find("/reanimation")!=-1)then
			m_asTargetTypes=0;
			m_asTargetTypes.AddEntry("SPRT");
			m_asTargetTypes.AddEntry("FOOD");
			m_asTargetTypes.AddEntry("NMST");
			m_asTargetTypes.AddEntry("VEC3");
			m_asTargetTypes.AddEntry("MGST");
			return;
		elseif(m_sTTPath.Find("/Repair")>=0) then
			m_asTargetTypes.AddEntry("BLDG");
		endif;
		if(m_sTTPath.Find("/Attack")!=-1 && CGameInst.ms_xSelectionInfo.Has(CSelectionInfo.AREA_WEAPON))then
			var CClntHndl xInvalid;
			AddRangeMarker(CGameInst.ms_xSelectionInfo.m_fAreaRange, true, pxObj^.GetHandle());
		endif;
		if(m_sTTPath.Find("MapPing")!=-1) then
		endif;
		if(m_asTargetTypes.NumEntries()==0 && m_asTargetClasses.NumEntries()==0 && m_asTargetExcludes.NumEntries()!=0)then
			m_asTargetTypes.AddEntry("ALL ");
		endif;
	endproc;

	proc void SetMouseCursor(string p_sCursor)
		var int iCursor;
		iCursor = CCursorMgr.Get().GetSpecialCursor(p_sCursor,m_sTaskByMouseCursor);
		if (iCursor!=m_iPreviousCursor) then
			CClientWrap.GetDesktop()^.SetCursor(iCursor);
			m_iPreviousCursor=iCursor;
		endif;
	endproc;

	export proc bool HandleCatchedMsg(bitset p_dwType, bitset p_dwFlags, int p_iKey, int p_iX, int p_iY)
		return false;
	endproc;

	export proc bool HandleMsg(bitset p_dwType, bitset p_dwFlags, int p_iKey, int p_iX, int p_iY)
		var bool bWTCWoGW=false; // Henry: WalkTo command without group walking
		var bool bCtrl = ((p_dwFlags&Msg.KM_CONTROL)!=0d);
		var bool bShift = ((p_dwFlags&Msg.KM_SHIFT)!=0d);
		var bool bAlt = ((p_dwFlags&Msg.KM_ALT)!=0d);
		var bool bOldCommandSystem = (CCommandBar.ms_bNewCommandSystem&&bShift)||(!CCommandBar.ms_bNewCommandSystem&&!bShift);
		var string sPrefix="";
		if(bCtrl)then
			sPrefix="Q_";
		endif;
		if(p_dwType==CInputController.MT_Tick)then
			UpdateMouseCursor();
			if(m_bMouseMarker)then
				if(m_pxRangeMarker!=null)then
					var ^CObj pxObj = m_pxRangeMarker^.GetObject();
					if(m_xRangeMarkerObj.IsValid())then
						var vec3 v1Pos=CClientWrap.GetScapeMgr().GetPickPoint();
						var vec3 v2Pos=pxObj^.GetPos();
						var vec3 vPos = v1Pos-v2Pos;
						m_pxRangeMarker^.m_vPos=vPos;
					else
						CMainController.Get().SetSecondaryInputController(false);
					endif;
				endif;
			endif;
			return true;
		endif;
		var int i;
		if(p_dwType!=CInputController.MT_MouseMove)then
			if(p_dwType==CInputController.MT_MouseLBtnUp)then
				var vec3 vPickPoint = CClientWrap.GetScapeMgr().GetPickPoint();
				var CClntHndl xHitObj = CClientWrap.GetObjMgr().GetHitObj();
				var ^CObj pxObj = xHitObj.GetObj();
				if(pxObj!=null)then pxObj=pxObj^.GetGroupedParentObj(); endif;
				if(m_sCommand=="Walk")then
					var real fShifting=Math.Sqrt(m_pxSelection^.NumEntries().ToReal());
					var bool bPlaySound=false;
					for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
						if(m_pxSelection^[i].IsValid())then
							var vec3 vShift;
							vShift.SetX(Random.MTRandF(-fShifting,fShifting));
							vShift.SetY(Random.MTRandF(-fShifting,fShifting));
							var string sFormation=CFormationMgr.Get().GetCurFormation();
							CEvt_GamePlayCommand.Send(m_pxSelection^[i], sPrefix+"Action", m_pxSelection^[i], vPickPoint+vShift, "/Walk"+sFormation);
							bPlaySound=true;
						endif;
					endfor;
					if (bPlaySound) then
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
					endif;
					CMainController.Get().SetSecondaryInputController(false);
				elseif(m_sCommand=="Attack")then
					if(xHitObj.IsValid() && (xHitObj.GetObj()^.GetType()=="CHTR"||xHitObj.GetObj()^.GetType()!="ANML"||xHitObj.GetObj()^.GetType()!="BLDG"))then
						var bool bPlaySound=false;
						if(pxObj!=null) then
							if(!CGameInputController.ms_bEGW)then
								var int k;
								for(k=0)cond(k<m_pxSelection^.NumEntries())iter(k++)do
									if(m_pxSelection^[k].IsValid())then
										CEvt_GamePlayCommand.Send(m_pxSelection^[k], sPrefix+"Fight", pxObj^.GetHandle(), vPickPoint, "");
									endif;
								endfor;
								bPlaySound=true;
							else
								CEvt_GamePlayCommand.Send(m_pxSelection^, sPrefix+"Fight", pxObj^.GetHandle(), vPickPoint, "");
								bPlaySound=true;
							endif;
						endif;
						if (bPlaySound) then
							CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
						endif;
						CMainController.Get().SetSecondaryInputController(false);
					else
						var real fShifting=Math.Sqrt(m_pxSelection^.NumEntries().ToReal());
						var bool bPlaySound=false;
						for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
							if(m_pxSelection^[i].IsValid())then
								var ^CAttribs pxAttr = m_pxSelection^[i].GetObj()^.GetAttribs();
								if (pxAttr!=null) then
									if (pxAttr^.GetValueInt("hitrange") > 0) then
										var CClntHndl xInvalid;
										CEvt_GamePlayCommand.Send(m_pxSelection^[i], sPrefix+"Fight", xInvalid, vPickPoint, "Scape");
										CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
										continue;
									endif;
								endif;
								var vec3 vShift;
								vShift.SetX(Random.MTRandF(-fShifting,fShifting));
								vShift.SetY(Random.MTRandF(-fShifting,fShifting));
								var string sFormation=CFormationMgr.Get().GetCurFormation();
								CEvt_GamePlayCommand.Send(m_pxSelection^[i], sPrefix+"Action", m_pxSelection^[i], vPickPoint+vShift, "/Walk"+sFormation);
								bPlaySound=true;
							endif;
						endfor;
						if (bPlaySound) then
							CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
						endif;
						CMainController.Get().SetSecondaryInputController(false);
					endif;
				elseif(m_sCommand == "Froze") then
					if (xHitObj.IsValid()) then
						var ^CObj pxO = xHitObj.GetObj();
						if (pxO^.GetType()!="SHIP") then xHitObj.Invalidate(); endif;
						m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
						CMainController.Get().SetSecondaryInputController(false);
					endif;
					if (m_pxItem!=null) then
						CEvt_GamePlayCommand.Send(m_pxItem^.GetHandle(), "Froze", xHitObj, vPickPoint, "Froze");
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
					endif;
				elseif(m_sCommand=="MapPing") then
					var vec3 vPos=CClientWrap.GetScapeMgr().GetPickPoint();
					var ^CInGameScreen pxIngameScreen = CUIStateMgr.Get().GetInGameScreen();
					if(pxIngameScreen!=null)then
						var ^CMiniMapWindow2 pxMinimpap= pxIngameScreen^.GetMiniMapWindow();
						if(pxMinimpap!=null) then
							pxMinimpap^.SetMapPing(vPos);
						endif;
					endif;
					CMainController.Get().SetSecondaryInputController(false);
				else
					var bool bIsSpecial = false;
					var string sCharacter = "";
					var string sSpecial = "";
					if (m_sCommand=="Action") then
						if (m_sTTPath.Find("/DismountAll")>=0) then
							var int i, iC = m_pxSelection^.NumEntries();
							var bool bPlaySound=false;
							for(i=0) cond(i<iC) iter(++i) do
								var ^CObj pxO = m_pxSelection^[i].GetObj();
								if(pxO!=null) then
									CEvt_GamePlayCommand.Send(pxO^.GetHandle(), sPrefix+"Action", xHitObj, vPickPoint, "/PrepareUnboard");
									bPlaySound=true;
								endif;
							endfor;
							if (bPlaySound) then
								CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
							endif;
							CMainController.Get().SetSecondaryInputController(false);
							return true;
						elseif(m_sTTPath.Find("/hu_ladder")>=0||m_sTTPath.Find("/seas_staircase")>=0) then
							var int i, iC = m_pxSelection^.NumEntries();
							var bool bPlaySound=false;
							for(i=0) cond(i<iC) iter(++i) do
								var ^CObj pxO = m_pxSelection^[i].GetObj();
								if(pxO!=null && m_sCursor !="no") then
									CEvt_GamePlayCommand.Send(pxO^.GetHandle(), m_sCommand, xHitObj, vPickPoint, m_sTTPath);
									bPlaySound=true;
								endif;
							endfor;
							if (bPlaySound) then
								CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
							endif;
							CMainController.Get().SetSecondaryInputController(false);
							return true;
						elseif(m_sTTPath.Find("/Repair")>=0)then
							var ^CObj pxRepairObj=xHitObj.GetObj();
							if(pxRepairObj!=null)then
								var int i, iC = m_pxSelection^.NumEntries();
								var bool bPlaySound=false;
								for(i=0) cond(i<iC) iter(++i) do
									var ^CObj pxO = m_pxSelection^[i].GetObj();
									if(pxO!=null) then
										var ^CAttribs pxAttribs = pxO^.GetAttribs();
										if(pxAttribs!=null && pxO^.GetTechTree().GetValueB(pxAttribs^.GetValue("ObjPath")+"/can_build",false))then
											CEvt_GamePlayCommand.Send(pxO^.GetHandle(), sPrefix+"Action", xHitObj, vPickPoint, "/Repair");
											bPlaySound=true;
										else
											var string sFormation=CFormationMgr.Get().GetCurFormation();
											CEvt_GamePlayCommand.Send(pxO^.GetHandle(), sPrefix+"Action", m_pxSelection^[i], vPickPoint, "/Walk"+sFormation);
										endif;
									endif;
								endfor;
								if(bPlaySound)then
									CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
								endif;
								CMainController.Get().SetSecondaryInputController(false);
							endif;
							return true;
						elseif(m_sTTPath.Find("/MountThatUnit")>=0)then
							var ^CObj pxUnit=xHitObj.GetObj();
							if(pxUnit!=null)then
								var ^CAttribs pxHitAttr = pxUnit^.GetAttribs();
								if(pxHitAttr!=null)then
									var int iTrpClassHit = pxHitAttr^.GetValueInt("transportclass");
									var int i, iC = m_pxSelection^.NumEntries();
									var bool bPlaySound=false;
									for(i=0)cond(i<iC)iter(++i)do
										var ^CObj pxO = m_pxSelection^[i].GetObj();
										if(pxO!=null)then
											var ^CAttribs pxAttribs = pxO^.GetAttribs();
											if(pxAttribs==null)then continue; endif;
											if(iTrpClassHit>=pxAttribs^.GetValueInt("transportclass"))then continue; endif;
											var array string asToks;
											var int iMaxPassengers=0;
											iMaxPassengers=pxAttribs^.GetValueInt("max_passengers");
											pxAttribs^.GetValue("passenger_guids").Split(asToks, "\n", true);
											if((iMaxPassengers-asToks.NumEntries())<1)then continue; endif;
											CEvt_GamePlayCommand.Send(pxO^.GetHandle(), sPrefix+"Action", xHitObj, vPickPoint, "/MountThatUnit");
											bPlaySound=true;
											break;
										endif;
									endfor;
									if(bPlaySound)then
										CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
									endif;
									CMainController.Get().SetSecondaryInputController(false);
								endif;
							endif;
							return true;
						elseif(m_sTTPath.Find( "/Moves" ) >= 0 ) then
							var int iPosition = m_sTTPath.FindRev( '/' );
							var int iLength = (m_sTTPath.GetLength() - iPosition) - 1;
							if ( (iPosition >= 0) && (iLength > 0) ) then
								sSpecial = m_sTTPath.Right( iLength );
								var CTechTree xTT = CGameWrap.GetClient().GetPlayer().GetPlayerTechTree();
								var ^CTechTree.CNode pxNodes = xTT.FindNode( m_sTTPath + "/locations" );
								if(pxNodes!=null)then
									var int iI, iC = pxNodes^.NumSubs();
									var array string asLocs;
									asLocs = iC;
									for(iI=0)cond(iI<iC)iter(++iI) do
										var ^CTechTree.CNode pxNode = pxNodes^.GetSub( iI );
										if ( pxNode != null ) then
											asLocs[iI] = pxNode^.GetValue();
											asLocs[iI] = asLocs[iI].Right( asLocs[iI].GetLength() - 1 );
										else
											asLocs[iI] = "";
										endif;
									endfor;
									iC = m_pxSelection^.NumEntries();
									for(iI=0)cond(iI<iC)iter(++iI) do
										var ^CObj pxMyObj = m_pxSelection^[iI].GetObj();
										if ( pxMyObj == null ) then continue; endif;
										var ^CAttribs pxAttribs = pxMyObj^.GetAttribs();
										if ( pxAttribs == null ) then continue; endif;
										var string sTTPath = pxAttribs^.GetValue( "ObjPath" );
										if ( sTTPath.IsEmpty() ) then continue; endif;
										if ( asLocs.FindEntry( sTTPath ) != -1 ) then
											bIsSpecial = true;
											sCharacter = sTTPath.Right( (sTTPath.GetLength() - sTTPath.FindRev( '/' )) - 1 );
										endif;
									endfor;
								endif;
							endif;
//							if(bIsSpecial)then
//							endif;
						endif;
					endif;
					var bool bAllTypes=false;
					if(m_asTargetTypes.FindEntry("ALL ")!=-1)then
						bAllTypes=true;
					endif;
					if(pxObj==null && !bAllTypes && m_asTargetTypes.FindEntry("VEC3")==-1)then
						return true;
					endif;
					if(pxObj!=null)then
						var string sFlag;
						var bool bFeignCorpse = false;
						var ^CAttribs pxAttr = pxObj^.GetAttribs();
						if(pxAttr!=null)then
							bFeignCorpse = pxAttr^.GetValueInt("Meat") == 0;
							sFlag = pxAttr^.GetValue("ObjFlag");
						endif;
						if(m_asTargetExcludes.FindEntry(pxObj^.GetClassName())!=-1)then
							return true;
						endif;
						if((m_sTTPath.Find("/reanimation")!=-1||m_sTTPath.Find("/Resurrect")!=-1) && pxObj^.GetType().AsString()=="FOOD" && bFeignCorpse)then
							return true;
						endif;
						if(m_asTargetClasses.NumEntries()>0 && m_asTargetClasses.FindEntry(pxObj^.GetClassName())==-1 && m_asTargetClasses.FindEntry(sFlag)==-1)then
							return true;
						elseif(!bAllTypes && m_asTargetTypes.FindEntry(pxObj^.GetType().AsString())==-1)then
							return true;
						else
							if(m_asTargetOwner.NumEntries()>0)then
								var bool bOwner = pxObj^.GetOwner() == CGameWrap.GetClient().GetPlayerID();
								var int iStatus = CGameWrap.GetDiplomacyMgr().GetMyOpinion(pxObj^.GetOwner());
								var bool bEnemy = iStatus==0;
								var bool bNeutral = iStatus==1;
								var bool bAlly = iStatus==2;
								if(bOwner && m_asTargetOwner.FindEntry("Owner")==-1)then
									return true;
								endif;
								if(!bOwner)then
									if(bAlly && m_asTargetOwner.FindEntry("Allies")==-1)then
										return true;
									endif;
									if(bNeutral && m_asTargetOwner.FindEntry("Neutrals")==-1)then
										return true;
									endif;
									if(bEnemy && m_asTargetOwner.FindEntry("Enemies")==-1)then
										return true;
									endif;
								endif;
							endif;
						endif;
					endif;
					var CClntHndl xHndl;
					if(pxObj!=null)then
						xHndl = pxObj^.GetHandle();
					endif;
					var string sCommandPath = m_sTTPath;
					var bool bGeneral = false;
					if(m_sTTPath.Find("/Walk")!=-1 || m_sTTPath.Find("/AggressiveTarget")!=-1 || m_sTTPath.Find("/Attack")!=-1)then
						bWTCWoGW=m_sTTPath.Find("/Attack")==-1&&(!CGameInputController.ms_bEGW);
						if(m_sTTPath.Find("/Walk")!=-1)then
							m_sTTPath+=CFormationMgr.Get().GetCurFormation();
						endif;
						bGeneral = true;
						var vec3 vDir = m_pxSelection^.GetPos() - vPickPoint;
						var real fDir=Math.ATan2(vDir.GetX(),vDir.GetY());
						m_sTTPath += " /FrmDir="+fDir.ToString();
						m_sTTPath += " /FrmSpc=2.7807";
					endif;
					var CObjList xList;
					for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
						if(m_pxSelection^[i].IsValid())then
							xList.Include(m_pxSelection^[i]);
						endif;
					endfor;
					if(m_sTTPath.Find("/Resurrect")!=-1)then
						if(pxObj!=null)then
							if(pxObj^.GetType().AsString()=="SPRT")then
								var int iSpiritHandle=CGameWrap.GetSpiritMgr().GetSpiritHandle(pxObj);
								if(iSpiritHandle!=-1)then
									m_sTTPath+=" Sprt "+iSpiritHandle.ToString();
								endif;
							else
								m_sTTPath+=" Guid "+pxObj^.GetGuid().ToString();
							endif;
						else
							var string sPos=vPickPoint.ToString();
							sPos.Replace(" ","_");
							m_sTTPath+=" Vec3 "+sPos;
						endif;
					endif;
					if(m_sTTPath.Find("/reanimation")!=-1)then
						if(pxObj!=null)then
							if(pxObj^.GetType().AsString()=="SPRT")then
								var int iSpiritHandle=CGameWrap.GetSpiritMgr().GetSpiritHandle(pxObj);
								if(iSpiritHandle!=-1)then
									m_sTTPath+=" Sprt "+iSpiritHandle.ToString();
								endif;
							else
								m_sTTPath+=" Guid "+pxObj^.GetGuid().ToString();
							endif;
						else
							var string sPos=vPickPoint.ToString();
							sPos.Replace(" ","_");
							m_sTTPath+=" Vec3 "+sPos;
						endif;
					endif;
					//if(m_sTTPath.Find("/Moves/")>=0 /*&& m_sTTPath.Find("/Special/")==-1*/ )then
					if(m_sTTPath.Find("/Moves/")>=0)then
						if(xList.NumEntries()>0)then
							var int im, iMC = xList.NumEntries();
							var bool bLocked=false, bMulti=iMC>1, bAllow;
							for(im=0)cond(im<iMC)iter(++im)do
//								bAllow=CMirageClnMgr.Get().IsOkAndReadyForAction(m_sTTPath, xList[im], bLocked, bMulti, bFound);
								bAllow=CMirageClnMgr.Get().IsOkAndReadyForAction(sCommandPath, xList[im], bLocked, bMulti);
								if(!(bAllow || bGeneral) || bLocked)then
									xList.DeleteEntry(im--); --iMC; continue;
								endif;
							endfor;
						endif;
					endif;
					var bool bPersonal = false;
					var int iUnits = xList.NumEntries();
					if(iUnits<=0)then
//						m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
							if(m_pxRangeMarker!=null)then
								m_pxObjMgr^.DeleteRangeMarker(m_pxRangeMarker);
								m_pxRangeMarker=null;
							endif;
						CMainController.Get().SetSecondaryInputController(false);
						return false;
					endif;
					if(iUnits>1)then
						var CTechTree xTechTree;
						var ^CTechTree.CNode pxTTNode;
						var ^CObj pxObj = xList[0].GetObj();
						if(pxObj!=null)then
							xTechTree = pxObj^.GetTechTree();
							pxTTNode = xTechTree.FindNode(sCommandPath);
						endif;
						if(pxTTNode!=null)then
							bPersonal = (pxTTNode^.GetSubValueI("personal", 0)==1);
						endif;
					endif;
//					if(m_sCursor == "no")then return true; endif;
					if(m_sCursor == "no"&&m_sTTPath.Find("Moves/CHTR/jetpack")<0&&m_sTTPath.Find("Moves/CHTR/jetleap")<0&&m_sTTPath.Find("Moves/CHTR/Jumpjet_0")<0&&m_sTTPath.Find("Moves/VHCL/Babbage_ExoJumpjet_0")<0&&m_sTTPath.Find("Moves/CHTR/pilot_fly")<0&&m_sTTPath.Find("Moves/VHCL/seas_jumpjet")<0)then
						m_sTTPath=m_sTTOriginal;
						return true;
					endif;
					if(!bPersonal||bOldCommandSystem)then
						if(bWTCWoGW)then
							for(i=0)cond(i<xList.NumEntries())iter(i++)do
								if(xList[i].IsValid())then
									CEvt_GamePlayCommand.Send(xList[i], sPrefix+m_sCommand, xHndl, vPickPoint, m_sTTPath);
								endif;
							endfor;
						else
							CEvt_GamePlayCommand.Send(xList, sPrefix+m_sCommand, xHndl, vPickPoint, m_sTTPath);
						endif;
					else
						CEvt_GamePlayCommand.Send(xList[0], sPrefix+m_sCommand, xHndl, vPickPoint, m_sTTPath);
					endif;
					if(bIsSpecial)then
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent( "voice_" + sCharacter + "_special_" + sSpecial, "", CSoundMgrCln.SOUND_VOLTRACK_GLOBAL );
					else
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
					endif;
					//HACK RT#6839 Urs/Interface - Beim von der Mauer springen gibt es keinen Zielpunkt-Feedback-Effekt
					if(m_sTTPath.Find("JumpOffWall")==-1)then
						CClientWrap.GetScapeMgr().AddScapeFeedbackPing(vPickPoint);
					endif;
					//END HACK
					if(bCtrl && !bShift)then
						CMainController.Get().SetQueueKey(true);
						return false;
					endif;
//					m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
					if(m_pxRangeMarker!=null)then
						m_pxObjMgr^.DeleteRangeMarker(m_pxRangeMarker);
						m_pxRangeMarker=null;
					endif;
					CMainController.Get().SetSecondaryInputController(false);
					return true;
				endif;
			endif;
			if(p_dwType==CInputController.MT_MouseRBtnUp)then
//				m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
				if(m_pxRangeMarker!=null)then
					m_pxObjMgr^.DeleteRangeMarker(m_pxRangeMarker);
					m_pxRangeMarker=null;
				endif;
				CMainController.Get().SetSecondaryInputController(false);
				return true;
			endif;
			if(p_dwType==CInputController.MT_MouseLBtnDown)then
				return true;
			endif;
			//CMainController.Get().SetSecondaryInputController(false);
		endif;
		return false;
	endproc;
	
	proc void UpdateMouseCursor()
		var CClntHndl xHitObj = CClientWrap.GetObjMgr().GetHitObj();
		var vec3 vPickPoint = CClientWrap.GetScapeMgr().GetPickPoint();
		m_sCursor = GetAction(CGameInst.ms_xSelectionInfo, xHitObj, vPickPoint);
//		SetMouseCursor(GetAction(CGameInst.ms_xSelectionInfo, xHitObj, vPickPoint));
		SetMouseCursor(m_sCursor);
	endproc;
	
	proc string GetAction(ref CSelectionInfo p_rxSel, CClntHndl p_xHitObj, vec3 p_vPickPoint)
		var ^CObj pxObj = p_xHitObj.GetObj();
		var string sHitType, sClassName, sFlag;
		var ^CAttribs pxAttr;
		if(pxObj!=null)then
			pxAttr = pxObj^.GetAttribs();
			if(pxAttr!=null)then
				sFlag = pxAttr^.GetValue("ObjFlag");
			endif;
			pxObj = pxObj^.GetGroupedParentObj();
			sHitType = pxObj^.GetType().AsString();
			sClassName = pxObj^.GetClassName();
		else
			sHitType = "VEC3";
			sClassName = "dummy";
		endif;
		if(m_asTargetExcludes.NumEntries()>0 && m_asTargetExcludes.FindEntry(sClassName)!=-1)then
			return "no";
		endif;
		if(m_asTargetClasses.NumEntries()>0 && m_asTargetClasses.FindEntry(sClassName)==-1 && m_asTargetClasses.FindEntry(sFlag)==-1 && sHitType!="VEC3")then
			return "no";
		elseif(m_asTargetTypes.FindEntry("ALL ")==-1 && m_asTargetTypes.FindEntry(sHitType)==-1)then
			if(m_asTargetTypes.FindEntry("MGST")!=-1)then
				var ^CPyramidCard pxCard = cast<CPyramidCard>(CWindowMgr.Get().GetHoveredWindow());
				if(pxCard!=null&&pxCard^.IsPreSpirit())then
					return "special";
				endif;
			endif;
			return "no";
		endif;
		if(pxObj!=null)then
			if(m_asTargetOwner.NumEntries()>0)then
				var bool bOwner = pxObj^.GetOwner() == CGameWrap.GetClient().GetPlayerID();
				var int iStatus = CGameWrap.GetDiplomacyMgr().GetMyOpinion(pxObj^.GetOwner());
				var bool bEnemy = iStatus==0;
				var bool bNeutral = iStatus==1;
				var bool bAlly = iStatus==2;
				if(bOwner && m_asTargetOwner.FindEntry("Owner")==-1)then
					return "no";
				endif;
				if(!bOwner)then
					if(bAlly && m_asTargetOwner.FindEntry("Allies")==-1)then
						return "no";
					endif;
					if(bNeutral && m_asTargetOwner.FindEntry("Neutrals")==-1)then
						return "no";
					endif;
					if(bEnemy && m_asTargetOwner.FindEntry("Enemies")==-1)then
						return "no";
					endif;
				endif;
			endif;
		endif;
		if(m_sTTPath.Find("MapPing")!=-1) then
			return "mapping";
		endif;
		if(m_sTTPath.Find("Moves/CHTR/jetpack")!=-1||m_sTTPath.Find("Moves/CHTR/jetleap")!=-1) then
			//MAX JUMP DISTANCE = 240 (originally 120)
			if((p_vPickPoint-CClientWrap.GetSelection().GetPos()).Abs2S()>24000.0)then
				return "no";
			else
				return "special";
			endif;
		endif;
		if(m_sTTPath.Find("Moves/CHTR/pilot_fly")!=-1) then
			//MAX JUMP DISTANCE = 180
			if((p_vPickPoint-CClientWrap.GetSelection().GetPos()).Abs2S()>18000.0)then
				return "no";
			else
				return "special";
			endif;
		endif;
		//Henry: set a special cursor for the build ladder action
		if(m_sTTPath.Find("/hu_ladder")>=0)then
			if(p_xHitObj.IsValid())then
				var ^CObj pxHitObj = p_xHitObj.GetObj();
				var ^CAttribs pxAttr = pxHitObj^.GetAttribs();
				if(pxAttr==null)then return "no"; endif;
//				if(pxAttr^.GetValueInt("IsDockable")==1 && pxHitObj^.IsEnemy())then
				if(pxAttr^.GetValueInt("IsDockable")==1)then
					return "build_ladder";
				else
					return "no";
				endif;
			endif;
		endif;
		//Henry: set a special cursor for the build stairs action
		if(m_sTTPath.Find("/seas_staircase")>=0)then
			if(p_xHitObj.IsValid())then
				var ^CObj pxHitObj = p_xHitObj.GetObj();
				var ^CAttribs pxAttr = pxHitObj^.GetAttribs();
				if(pxAttr==null)then return "no"; endif;
//				if(pxAttr^.GetValueInt("IsDockable")==1 && pxHitObj^.IsEnemy())then
				if(pxAttr^.GetValueInt("IsDockable")==1)then
					return "build_staircase";
				else
					return "no";
				endif;
			endif;
		endif;
//		if(m_sTTPath.Find("/reanimation")>=0)then
//			if(p_xHitObj.IsValid())then
//				var ^CObj pxHitObj = p_xHitObj.GetObj();
//				if(pxHitObj^.IsEnemy()&&pxHitObj^.GetClassName().Find("_worker_food")==-1)then
//					return "no";
//				endif;
//			endif;
//		endif;
		//define the cursor for the jumpjet action depending on maximal distance
		if(m_sTTPath.Find("Moves/CHTR/Jumpjet_0")!=-1) then
			//MAX JUMP DISTANCE = 500
			if((p_vPickPoint-CClientWrap.GetSelection().GetPos()).Abs2S()>50000.0)then
				return "no";
			else
				return "special";
			endif;
		endif;
		if(m_sTTPath.Find("Moves/VHCL/Babbage_ExoJumpjet_0")!=-1) then
			//MAX JUMP DISTANCE = 300
			if((p_vPickPoint-CClientWrap.GetSelection().GetPos()).Abs2S()>30000.0)then
				return "no";
			else
				return "special";
			endif;
		endif;
		if(m_sTTPath.Find("Moves/VHCL/seas_jumpjet")!=-1) then
			//MAX JUMP DISTANCE = 300
			if((p_vPickPoint-CClientWrap.GetSelection().GetPos()).Abs2S()>30000.0)then
				return "no";
			else
				return "special";
			endif;
		endif;
		//Henry: some special cases for different actions...
		if(m_sTTPath.Find("Moves/CHTR/deplenish")!=-1)then
			var ^CAttribs pxAttr = pxObj^.GetAttribs();
			if(pxAttr==null)then return "no"; endif;
			if(pxAttr^.GetValueInt("transportclass")<1)then
				return "no";
			endif;
			var real fScapeZ = CGameWrap.GetScapeMgr().GetHeight(pxObj^.GetPos().GetX(), pxObj^.GetPos().GetY());
			var real fSea = CGameWrap.GetScapeMgr().GetSeaLevel();
			if(fScapeZ+5.0f<fSea)then
				return "no";
			endif;
		endif;
		if(m_sTTPath.Find("Moves/CHTR/schliemann_sacrifice")!=-1) then
			var string sClass = pxObj^.GetClassName();
			if(sClass=="schliemann_s0")then
				return "no";
			endif;
		endif;
		if(m_sTTPath.Find("Moves/CHTR/eruption")!=-1)then
			var CObjQueryCln xOQ;
			var CObjList xObjects;
			xOQ.SetClass("volcano");
			xOQ.SetOwner(-1);
			xOQ.RegionCircle(p_vPickPoint, 30.0);
			xOQ.Execute(xObjects);
			var int i, iC = xObjects.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CObj pxObj=xObjects[i].GetObj();
				if(pxObj!=null)then
					return "no";
				endif;
			endfor;
			return "special";
		endif;
		if(m_sTTPath.Find("Moves/CHTR/earth_quake")!=-1)then
			var CObjQueryCln xOQ;
			var CObjList xObjects;
			xOQ.SetClass("helper_rumble");
			xOQ.SetOwner(-1);
			xOQ.RegionCircle(p_vPickPoint, 80.0);
			xOQ.Execute(xObjects);
			var int i, iC = xObjects.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CObj pxObj=xObjects[i].GetObj();
				if(pxObj!=null)then
					return "no";
				endif;
			endfor;
			return "special";
		endif;
		if(m_sTTPath.Find("Moves/CHTR/Tesla_DstrVhcl_0")!=-1)then
			if(pxAttr!=null&&pxAttr^.GetValueBool("flying_unit"))then
				return "no";
			endif;
		endif;
		if(m_sTTPath.Find("/Attack")!=-1)then
			var string sReturn = "attack";
			if(p_rxSel.m_xMaxRangeObj.IsValid())then
				var ^CObj pxMaxRangeObj = p_rxSel.m_xMaxRangeObj.GetObj();
				var real fObjSize=1.0;
				if(pxMaxRangeObj!=null)then
					fObjSize = pxMaxRangeObj^.GetCollisionRadius();
				endif;
				var vec3 vPos = p_vPickPoint;
				var vec3 vHitSize;
				if(p_xHitObj.IsValid())then
					var ^CObj pxHitObj = p_xHitObj.GetObj();
					vPos=pxHitObj^.GetPos();
					vHitSize+=pxHitObj^.GetSize();
					vHitSize.SetZ(0.0);
					vHitSize*=0.5;
				endif;
				var real fRange = (fObjSize+vHitSize.Abs())+p_rxSel.m_fMaxRange;
				var real fMinRange = (p_rxSel.m_fMinRange+fObjSize);
				var real fDistance = (vPos-pxMaxRangeObj^.GetPos()).Abs();
				if(CGameInst.ms_xSelectionInfo.Has(CSelectionInfo.AREA_WEAPON))then
					sReturn += "_area_weapon";
					if(fDistance < fMinRange)then
						sReturn += "_invalid";
					endif;
				endif;
				if(fDistance > fRange)then
					sReturn += "_walk";
				endif;
			endif;
			return sReturn;
		elseif(m_sTTPath.Find("/AggressiveTarget")!=-1)then
			return "walk_aggro";
		elseif(m_sTTPath.Find("/Walk")!=-1)then
			return "walk";
		elseif(m_sTTPath.Find("/DismountAll")!=-1)then
			return "unload";
		elseif(m_sTTPath.Find("/MountThatUnit")>=0)then
			var ^CAttribs pxA = pxObj^.GetAttribs();
			if(pxA!=null)then
				var int iTrpClassU = pxA^.GetValueInt("transportclass"); // Henry: unit
				if(pxObj^.GetType().AsString()!="CHTR"&&p_rxSel.m_iMaxTransportClass<2)then
				elseif(iTrpClassU<p_rxSel.m_iMaxTransportClass)then
					return "load";
				else
					return "no";
				endif;
			endif;
			return "no";
		elseif(m_sTTPath.Find("/Moves/")!=-1)then
			if(m_asTargetTypes.FindEntry("MGST")!=-1)then
				var ^CPyramidCard pxCard = cast<CPyramidCard>(CWindowMgr.Get().GetHoveredWindow());
				if(pxCard!=null)then
					if(pxCard^.IsPreSpirit())then
						return "special";
					else
						return "no";
					endif;
				endif;
			endif;
			return "special";
		elseif(m_sTTPath.Find("/Repair")>=0) then
			var ^CAttribs pxA = pxObj^.GetAttribs();
			if(pxA!=null) then
				var int iHP = pxA^.GetValueInt("hitpoints");
				var int iMaxHP = pxA^.GetValueInt("maxhitpoints");
				if(iHP<iMaxHP) then
					return "build";
				else
					return "no";
				endif;
			endif;
		elseif((m_sTTPath.Find("Build/SHIP/ninigi_mineship_mine")>=0 || m_sTTPath.Find("Build/SHIP/ninigi_water_turret")>=0)
		&& CClientWrap.GetScapeMgr().GetHeight(p_vPickPoint.GetX(),p_vPickPoint.GetY())<=CClientWrap.GetScapeMgr().GetSeaLevel())then
			return "special";
		endif;
		return "";
	endproc;
	
	export proc void ResetController()
		m_bMouseMarker = false;
		if(m_pxRangeMarker!=null)then
//			CClientWrap.GetObjMgr().DeleteAllRangeMarkers();
			m_pxObjMgr^.DeleteRangeMarker(m_pxRangeMarker);
		endif;
		m_pxRangeMarker = null;
		SetMouseCursor("");
	endproc;
	
	export proc string GetCommand()
		return m_sCommand;
	endproc;
	
	export proc string GetTTPath()
		return m_sTTPath;
	endproc;
	
	export proc bool IsReanimActive()
		if(m_sCommand=="Action" && m_sCursor=="special" && (m_sTTPath.Find("/Resurrect")!=-1 || m_sTTPath.Find("/reanimation")!=-1))then
			return true;
		endif;
		return false;
	endproc;
	
	export proc void ReanimatePyCO(string p_sSrvrHndl, bitset p_dwKeyModifier)
		var bool bCtrl = ((p_dwKeyModifier&Msg.KM_CONTROL)!=0d);
		var bool bShift = ((p_dwKeyModifier&Msg.KM_SHIFT)!=0d);
		var bool bAlt = ((p_dwKeyModifier&Msg.KM_ALT)!=0d);
		var bool bOldCommandSystem = (CCommandBar.ms_bNewCommandSystem&&bShift)||(!CCommandBar.ms_bNewCommandSystem&&!bShift);
		var CObjList xList;
		var int i;
		for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
			if(m_pxSelection^[i].IsValid())then
				xList.Include(m_pxSelection^[i]);
			endif;
		endfor;
		var string sCommandPath = m_sTTPath;
		if(xList.NumEntries()>0)then
			var int im, iMC = xList.NumEntries();
			for(im=0)cond(im<iMC)iter(++im)do
				if(!CMirageClnMgr.Get().IsOkAndReadyForAction(sCommandPath, xList[im]))then
					xList.DeleteEntry(im--); --iMC; continue;
				endif;
			endfor;
		endif;
		var bool bIsSpecial = false;
		var string sCharacter = "";
		var string sSpecial = "";
		var int iPosition = m_sTTPath.FindRev('/');
		var int iLength = (m_sTTPath.GetLength() - iPosition) - 1;
		if((iPosition >= 0) && (iLength > 0))then
			sSpecial = m_sTTPath.Right(iLength);
			var CTechTree xTT = CGameWrap.GetClient().GetPlayer().GetPlayerTechTree();
			var ^CTechTree.CNode pxNodes = xTT.FindNode(m_sTTPath + "/locations");
			if(pxNodes!=null)then
				var int iI, iC = pxNodes^.NumSubs();
				var array string asLocs;
				asLocs = iC;
				for(iI=0)cond(iI<iC)iter(++iI) do
					var ^CTechTree.CNode pxNode = pxNodes^.GetSub(iI);
					if(pxNode != null)then
						asLocs[iI] = pxNode^.GetValue();
						asLocs[iI] = asLocs[iI].Right(asLocs[iI].GetLength() - 1);
					else
						asLocs[iI] = "";
					endif;
				endfor;
				iC = m_pxSelection^.NumEntries();
				for(iI=0)cond(iI<iC)iter(++iI) do
					var ^CObj pxMyObj = m_pxSelection^[iI].GetObj();
					if(pxMyObj == null)then continue; endif;
					var ^CAttribs pxAttribs = pxMyObj^.GetAttribs();
					if(pxAttribs == null)then continue; endif;
					var string sTTPath = pxAttribs^.GetValue("ObjPath");
					if(sTTPath.IsEmpty())then continue; endif;
					if(asLocs.FindEntry(sTTPath)!= -1)then
						bIsSpecial = true;
						sCharacter = sTTPath.Right((sTTPath.GetLength() - sTTPath.FindRev('/')) - 1);
					endif;
				endfor;
			endif;
		endif;
		var int iUnits = xList.NumEntries();
		if(iUnits<=0)then
			if(m_pxRangeMarker!=null)then
				m_pxObjMgr^.DeleteRangeMarker(m_pxRangeMarker);
				m_pxRangeMarker=null;
			endif;
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;
		var bool bPersonal = false;
		if(iUnits>1)then
			var CTechTree xTechTree;
			var ^CTechTree.CNode pxTTNode;
			var ^CObj pxObj = xList[0].GetObj();
			if(pxObj!=null)then
				xTechTree = pxObj^.GetTechTree();
				pxTTNode = xTechTree.FindNode(sCommandPath);
			endif;
			if(pxTTNode!=null)then
				bPersonal = (pxTTNode^.GetSubValueI("personal", 0)==1);
			endif;
		endif;
		var CClntHndl xHndl;
		var vec3 vPickPoint = CClientWrap.GetScapeMgr().GetPickPoint();
		m_sTTPath+=" Pyco "+p_sSrvrHndl;
		if(!bPersonal||bOldCommandSystem)then
			CEvt_GamePlayCommand.Send(xList, m_sCommand, xHndl, vPickPoint, m_sTTPath);
		else
			CEvt_GamePlayCommand.Send(xList[0], m_sCommand, xHndl, vPickPoint, m_sTTPath);
		endif;
		if(bIsSpecial)then
			CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent( "voice_" + sCharacter + "_special_" + sSpecial, "", CSoundMgrCln.SOUND_VOLTRACK_GLOBAL );
		else
			CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
		endif;
		CClientWrap.GetScapeMgr().AddScapeFeedbackPing(vPickPoint);
		if(bCtrl && !bShift)then
			CMainController.Get().SetQueueKey(true);
			return;
		endif;
		if(m_pxRangeMarker!=null)then
			m_pxObjMgr^.DeleteRangeMarker(m_pxRangeMarker);
			m_pxRangeMarker=null;
		endif;
		CMainController.Get().SetSecondaryInputController(false);
	endproc;
	
endclass;

