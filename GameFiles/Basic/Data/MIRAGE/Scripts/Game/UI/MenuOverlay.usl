class CMenuOverlay inherit CWindow

	var ^CDesktop			m_pxDesktop;
	var int 				m_iWidth;
	var int 				m_iHeight;
	
	var	^CPane				m_pxTopBar;
	var	^CPane				m_pxBottomBar;
	
	var ^CStaticCtrl		m_pxTooltip;
	var bool				m_bIsToolTip;
	var int					m_iCheckTimer;
	var CGameTime			m_xTime;
	
	var ^CStaticCtrl		m_pxVersionInfo;

	var array ^CStaticCtrl	m_apxAlphaSpace;
	
	var int 				m_iTileWidth;
	var int 				m_iTileHeight;

	export constructor(bool p_bMenue)

		m_pxDesktop=CClientWrap.GetDesktop();
		m_iWidth=m_pxDesktop^.GetWidth();
		m_iHeight=m_pxDesktop^.GetHeight();
		
		m_iTileWidth=128 * CGameInst.ms_iUIScaleFactor;
		m_iTileHeight=128 * CGameInst.ms_iUIScaleFactor;
		
		SetSize(m_iWidth,m_iHeight);
		SetTransparent(true);
		SetBackground(false);
		
		//Top Bar
		m_pxTopBar=new CPane();
		m_pxTopBar^.SetPos(0,0);
		var color xColor={{0,0,0,255}};
		m_pxTopBar^.SetColor(xColor);
		m_pxTopBar^.SetSize(m_iWidth,((m_iHeight.ToReal()/100.0f)*8.333).ToInt());
		m_pxTopBar^.SetVisible(true);
		AddChild(m_pxTopBar);
		//Bottom Bar
		m_pxBottomBar=new CPane();
		m_pxTopBar^.SetPos(0,(m_iHeight.ToReal()-(m_iHeight.ToReal()/100.0f)*8.333).ToInt()+1);
		xColor={{0,0,0,255}};
		m_pxBottomBar^.SetColor(xColor);
		m_pxBottomBar^.SetSize(m_iWidth,((m_iHeight.ToReal()/100.0f)*8.333).ToInt());
		m_pxBottomBar^.SetVisible(true);
		AddChild(m_pxBottomBar);
		
		if(!p_bMenue)then	
			AddAlphaTiles("Top");
			AddAlphaTiles("Bottom");
			AddAdditionalOverlay();
			return();
		endif;
		
		AddAlphaTiles("Top");
		AddAlphaTiles("Bottom");
		AddAdditionalOverlay();
		
		//Version Info
		var string sVersion;
		var string sText;
		if(CVersionInfo.IsReleaseBuild())then
			sVersion=" Rel ";
		elseif(CVersionInfo.IsCheckedBuild())then
			sVersion=" Chk ";
		elseif(CVersionInfo.IsDebugBuild())then			
			sVersion=" Dbg ";
		endif;
		sText+=CVersionInfo.GetVersionInfoString()+" "+sVersion+" "+CVersionInfo.GetVersionDate();
		m_pxVersionInfo=new	CStaticCtrl();
		xColor={{128,128,128,255}};
		m_pxVersionInfo^.SetTextColor(xColor);
		m_pxVersionInfo^.SetTextAlign(1);
		m_pxVersionInfo^.SetWidth(240 * CGameInst.ms_iUIScaleFactor);
		m_pxVersionInfo^.SetPos(m_iWidth-m_pxVersionInfo^.GetWidth(),(m_iHeight.ToReal()-(m_iHeight.ToReal()/100.0f)*7.5).ToInt());
		m_pxVersionInfo^.SetText(sText);
		m_pxVersionInfo^.SetTextAlign(0);
		m_pxVersionInfo^.SetTransparent(true);
		m_pxVersionInfo^.SetBackground(false);
		AddChild(m_pxVersionInfo);
		
		//Tooltip
		m_pxTooltip=new	CStaticCtrl();
		xColor={{132,132,132,255}};
		m_pxTooltip^.SetTextColor(xColor);
		//m_pxTooltip^.SetPos(10,710);
		m_pxTooltip^.SetPos(((m_iWidth.ToReal()/100.0f)*6.25f).ToInt(),(m_iHeight.ToReal()-(m_iHeight.ToReal()/100.0f)*6.25).ToInt());
		m_pxTooltip^.SetText(" ");
		m_pxTooltip^.SetTextAlign(0);
		m_pxTooltip^.SetTransparent(true);
		m_pxTooltip^.SetBackground(false);
		AddChild(m_pxTooltip);
		
		//Tooltip Hack
		m_iCheckTimer=SetTimer(50,true);
		m_bIsToolTip=false;
	endconstructor;
	
	export proc bool SetToolTip(string p_sTooltip)
		if(m_pxTooltip!=null)then
			m_pxTooltip^.SetText(p_sTooltip);
		endif;
		m_xTime=CTimeMgr.Get().GetTime();
		m_bIsToolTip=true;
		return(true);
	endproc;
	
	proc bool AddAlphaTiles(string p_sParam)
		//Alpha Tiles 
		var int i,iC=((m_iWidth.ToReal()/32.0f).ToInt());
		for(i=0)cond(i<iC)iter(i++)do
			var ^CStaticCtrl pxTmp=new CStaticCtrl();
			if(p_sParam=="Top")then
				pxTmp^.SetBitmap("menue/decoration/cinema_topsoft.tga");	
				pxTmp^.SetPos(i*32,((m_iHeight.ToReal()/100.0f)*8.333).ToInt());
			else
				pxTmp^.SetBitmap("menue/decoration/cinema_bottomsoft.tga");	
				pxTmp^.SetPos(i*32,(m_iHeight.ToReal()-(m_iHeight.ToReal()/100.0f)*8.333).ToInt()-5);
			endif;
			pxTmp^.SetTransparent(true);
			pxTmp^.SetBackground(false);
			pxTmp^.SetSize(32 * CGameInst.ms_iUIScaleFactor,6 * CGameInst.ms_iUIScaleFactor);
			AddChild(pxTmp);
		endfor;
		return(true);
	endproc;
	
	proc bool AddAdditionalOverlay()
		
		//Places corner tiles

		var ^COverlayTile pxTopLeft=new COverlayTile("topleft");
		pxTopLeft^.SetPos(0,((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
		AddChild(pxTopLeft);
		
		var ^COverlayTile pxTopRight=new COverlayTile("topright");
		pxTopRight^.SetPos(m_iWidth-m_iTileWidth,((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
		AddChild(pxTopRight);
		
		var ^COverlayTile pxBottomLeft=new COverlayTile("bottomleft");
		pxBottomLeft^.SetPos(0,m_iHeight-((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
		AddChild(pxBottomLeft);
		
		var ^COverlayTile pxBottomRight=new COverlayTile("bottomright");
		pxBottomRight^.SetPos(m_iWidth-m_iTileWidth,m_iHeight-((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
		AddChild(pxBottomRight);
		
		//Places edge tiles
		AddTile("top");
		AddTile("bottom");
		AddTile("left");
		AddTile("right");
		AddTile("backtile");
		
		return(true);
	endproc;
	
	proc bool AddTile(string p_sEdge)
		var int iTilesX=(m_iWidth.ToReal()/m_iTileWidth.ToReal()).ToInt()-1;
		var int iRestX=m_iWidth%m_iTileWidth;
		
		var int iOffsetY=((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64;
		var int iTilesY=(((m_iHeight-(iOffsetY*2))-m_iTileHeight).ToReal()/m_iTileHeight.ToReal()).ToInt();
		var int iRestY=(m_iHeight-(iOffsetY*2)-m_iTileHeight*2)%m_iTileHeight;
		
		var int i;
		if(p_sEdge=="top"||p_sEdge=="bottom"||p_sEdge=="backtile")then
			for(i=0)cond(i<iTilesX)iter(i++)do
				if(i==(iTilesX-1))then
					if(iRestX>0)then
						var ^COverlayTile pxTmp=new COverlayTile(p_sEdge);
						if(p_sEdge=="top")then
							pxTmp^.SetPos(m_iTileWidth+(m_iTileWidth*i),((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
							pxTmp^.SetWidth(iRestX);
							var int j;
							for(j=0)cond(j<iTilesY-1)iter(j++)do
								var ^COverlayTile pxBackTileTmp=new COverlayTile(p_sEdge);
								pxBackTileTmp^.SetBitmap("menue/decoration/mapoverlay_backtile.tga");
								pxBackTileTmp^.SetPos(m_iTileWidth+(i*m_iTileWidth),m_iTileHeight+(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(m_iTileHeight*j));	
								pxBackTileTmp^.SetWidth(iRestX);
								AddChild(pxBackTileTmp);
							endfor;
						elseif(p_sEdge=="bottom")then
							pxTmp^.SetPos(m_iTileWidth+(m_iTileWidth*i),m_iHeight-((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
							pxTmp^.SetWidth(iRestX);
						endif;
						AddChild(pxTmp);
					else
						break;
					endif;
				else
					if(p_sEdge=="backtile")then
						var int j;
						for(j=0)cond(j<iTilesY-1)iter(j++)do
							var ^COverlayTile pxBackTileTmp=new COverlayTile(p_sEdge);
							pxBackTileTmp^.SetBitmap("menue/decoration/mapoverlay_backtile.tga");
							pxBackTileTmp^.SetPos(m_iTileWidth+(m_iTileWidth*i),(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(j*m_iTileHeight)+m_iTileHeight);
							AddChild(pxBackTileTmp);
						endfor;	
						continue;
					endif;
					var ^COverlayTile pxTmp=new COverlayTile(p_sEdge);
					if(p_sEdge=="top")then
						pxTmp^.SetPos(m_iTileWidth+(m_iTileWidth*i),((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
					elseif(p_sEdge=="bottom")then
						pxTmp^.SetPos(m_iTileWidth+(m_iTileWidth*i),m_iHeight-((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64);
					endif;
					AddChild(pxTmp);
				endif;
			endfor;
		else	
			for(i=0)cond(i<iTilesY)iter(i++)do
				if(i==(iTilesY-1))then
					if(iRestY>0)then
						var ^COverlayTile pxTmp=new COverlayTile(p_sEdge);
						if(p_sEdge=="left")then
							pxTmp^.SetPos(0,m_iTileWidth+(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(m_iTileHeight*i));	
							pxTmp^.SetHeight(iRestY);
							var int j;
							for(j=0)cond(j<iTilesX)iter(j++)do
								var ^COverlayTile pxBackTileTmp=new COverlayTile(p_sEdge);
								pxBackTileTmp^.SetBitmap("menue/decoration/mapoverlay_backtile.tga");
								pxBackTileTmp^.SetPos(m_iTileWidth+(j*m_iTileWidth),m_iTileWidth+(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(m_iTileHeight*i));	
								pxBackTileTmp^.SetHeight(iRestY);
								if(j==iTilesX-1)then
									pxBackTileTmp^.SetWidth(iRestX);
								endif;
								AddChild(pxBackTileTmp);
							endfor;
						elseif(p_sEdge=="right")then
							pxTmp^.SetPos(m_iWidth-m_iTileWidth,m_iTileHeight+(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(m_iTileHeight*i));	
							pxTmp^.SetHeight(iRestY);
						endif;
						AddChild(pxTmp);
					else
						break;
					endif;
				else
					var ^COverlayTile pxTmp=new COverlayTile(p_sEdge);
					if(p_sEdge=="left")then
						pxTmp^.SetPos(0,m_iTileWidth+(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(m_iTileHeight*i));	
					elseif(p_sEdge=="right")then
						pxTmp^.SetPos(m_iWidth-m_iTileWidth,m_iTileHeight+(((m_iHeight.ToReal()/100.0f)*8.333).ToInt()-64)+(m_iTileHeight*i));	
					endif;
					AddChild(pxTmp);
				endif;
			endfor;
		endif;	
		return(true);
	endproc;
	
	proc bool OnTimer(int p_iID)
		if (p_iID==m_iCheckTimer) then
			var real fTime=(CTimeMgr.Get().GetTime()-m_xTime).GetSecondsF();
			if(fTime>0.1&&m_bIsToolTip)then
				m_pxTooltip^.SetText(" ");
				m_bIsToolTip=false;
			endif;
		endif;
		return(true);
	endproc;	
	
endclass;

class COverlayTile inherit CStaticCtrl

	export constructor(string p_sType)
		SetBitmap("menue/decoration/mapoverlay_"+p_sType+".tga");
		SetTransparent(true);
		SetBackground(false);
		SetSize(128 * CGameInst.ms_iUIScaleFactor,128 * CGameInst.ms_iUIScaleFactor);
		SetBitmapAutoSize(false);
	endconstructor;
	
	destructor()
	enddestructor;

endclass;
